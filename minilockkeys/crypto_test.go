package minilockkeys

import (
  "testing"
)

// ID is "2453m8h7r3stzV8NeG4WzrFhsXTTsXTodQA2S6R9J2dfuh"
func testKey1() (*NaClKeypair, error) {
  return FromEmailAndPassphrase("cathalgarvey@some.where", "this is a password that totally works for minilock purposes")
}

// ID is "xjjCm44Nuj4DyTBuzguJ1d7K6EdP2TWRYzsqiiAbfcGTr"
func testKey2() (*NaClKeypair, error) {
  return FromEmailAndPassphrase("joeblocks@else.where", "whatever I write won't be good enough for the NSA")
}

func Test_KeyIdentity(t *testing.T) {
  gen_key, err := testKey1()
  if err != nil {
    t.Fatal(err.Error())
  }
  // Generated by miniLock with same credentials:
  keyID := "2453m8h7r3stzV8NeG4WzrFhsXTTsXTodQA2S6R9J2dfuh"
  genID, err := gen_key.EncodeID()
  if err != nil {
    t.Error(err.Error())
  }
  if keyID != genID {
    t.Error("Key IDs don't match:\nShould be:\t" + keyID + "\nBut made:\t" + genID)
  }
}

func Test_CryptoRoundtrip(t *testing.T) {
  gen_key, err := testKey1()
  if err != nil {
    t.Fatal(err.Error())
  }
  other_key, err := testKey2() // FromEmailAndPassphrase("moo@cow.field", "not very good at passwords")
  if err != nil {
    t.Fatal(err.Error())
  }
  gen_pk := gen_key.PublicOnly()
  other_pk := other_key.PublicOnly()
  if gen_pk.HasPrivate() {
    t.Error("Generated public key should not have private part.")
  }
  if other_pk.HasPrivate() {
    t.Error("Generated public key should not have private part.")
  }
  nonce1 := []byte("123456789012345678901234")
  msg1 := "Attack at dawn!"
  // Encrypt(plaintext, nonce []byte, to *NaClKeypair) (ciphertext []byte)
  // Decrypt(ciphertext, nonce []byte, from *NaClKeypair) (plaintext []byte, err error)
  ct1, err := gen_key.Encrypt([]byte(msg1), nonce1, other_pk)
  if err != nil {
    t.Error(err.Error())
  }
  pt1, err := other_key.Decrypt(ct1, nonce1, gen_pk)
  if err != nil {
    t.Error(err.Error())
  }
  if string(pt1) != msg1 {
    t.Error("Decrypted message doesn't match original: '"+msg1+"' vs '"+string(pt1)+"'")
  }
}
